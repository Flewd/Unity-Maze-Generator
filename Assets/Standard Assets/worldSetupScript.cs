using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

/* Randomly Generated Maze Game
 * By: Michael Flood
 * 
 * This Game is a simple Maze Game using a Randomly Generated maze of any given size.
 * 
 * A maze is generated and the player is placed somewhere in the middle of a maze that only has one exit.
 * The Exit is blocked by a white block that only lowers when the player has collected the 4 keys that
 * have been placed in the four corners of the maze. Once all four keys are collected then the door will
 * lower allowing the player to escape.
 * 
 * Each time you step on a new cube that you have not preivously stepped on it will turn white and count how
 * how many you have traversed. For every ten cubes that you step on you are able to click a block and drop
 * it down to extend your path at the cost of 10 of your traversed panels. Naturally larger mazes will give you more
 * oppurtunities to drop walls.
 * 
 * Note: The action of droping walls is determined by the position of the mouse pointer, not the center of your view.
 * */


public class worldSetupScript : MonoBehaviour {

    //C#'s vector2 saves the values as floats but to access the array of cells you need to use an integer,
    //so instead of using two seperate int variables I made a struct that acts as an Integer Vector2
    public struct IntVector2
    {
        public int x;
        public int y;

        public IntVector2(int _x, int _y)
        {
            x = _x;
            y = _y;
        }
    }

    //changing these numbers will scale the maze size
    //works with uneven sides as well
    //setting the size above [50,50] requires a bit of time to generate
    public static int mazeSizeX = 25;
    public static int mazeSizeY = 25;

    static int costToLowerWall = 10;    //change if you want to limit or increase the use of the wall lowering ability

    private int keysCollected = 0;  //count how many keys have been collected
    int panelsSteppedOn = 0;        //this increments for every new panel stepped on

    public GameObject panelsSteppedOnGUI;   //text that displays your current stock of panels to spend

	//spacing between each cube placed
	private static float CELL_SEPERATION = 5f;
	//How big the cubes in the world are (currently equal to the spacing)
	private static float CELL_SCALE = 5f;
	
	//A link to the camera object.  Mostly just thought you might
	//Find it useful to see how to grab a game object from the scene by name, though
	//you shouldn't do this too often as it is expensive.
	private GameObject m_mainCamera;
    private GameObject m_firstPersonController;

    private RaycastHit hitInfo;     //raycast hitinfo to get more information about what the raycast collided with
	
	//The 2D array to hold our grid of cubes
    //Initialze the array of GameObjects
    private GameObject[,] m_gameObjectArray = new GameObject[mazeSizeX, mazeSizeY];

    private System.Random r;

    private IntVector2 exitLocation;    //stores the cell location in the array of the exit door so it can be opened when the keys are found
    bool isDoorOpened = false;  //flag to know whether the exit has been opened

    public Ray ray;     //ray variable used for raycasting from the mouse pointer

    bool oldMouse;      //old mouse state from last update to make sure when someone clicks the mouse and holds, the program only accepts it as one mouse click
    bool mouse;         //current mouse state
	
	// Use this for initialization
	void Start () {
		
		m_mainCamera = GameObject.Find("Main Camera");
        m_firstPersonController = GameObject.Find("Main Camera/First Person Controller");
		r = new System.Random();

        generateMaze(); //generate maze
        placePlayerStartPosition(); //place player in a pathway towards the center of the maze
        placeKeys();    //set the location for the 4 keys
    }

     // Update is called once per frame
     void Update()
    {
        checkToChangePanelColor();

         checkForKeyPickUp();

         checkIfDoorShouldOpen();

         checkMouseClick();
    }

     /*The main maze generation logic which is based off of Prim's Algorithm
      * 
      * The maze is generated by first filling the array with random colored cells based off of the size of the maze that is declared above.
      * Each cell is randomly given a weight from 1-99 which is used to create the random path ways.
      * Then the perimeter of the maze is raised and marked as walls.
      * An exit point is randomly chosen from the perimeter and is marked and stored as the exit.
      * It then moves to the next node in the opposite direction that the exit was placed in.
      * 
      * ---Loop Begins Here
      * It then marks that node as a path and lowers it while marking its neighboring cells as frontier cells.
      * It then picks the cheapest frontier cell that is connected to the most recent lowered cell.
      * Then decides whether that cell should become a path or a wall depending on how many paths are currently connected to it
      * If the last lowered cell has no more frontier cells connecting it then It searches for the next lowest weighted frontier cell and continues the process.
      * This process continues until no frontier cells remain
      * ----End Loop
    */
     void generateMaze()
     {
         //Loop through the array
         for (int i = 0; i < mazeSizeX; i++)
         {
             for (int j = 0; j < mazeSizeY; j++)
             {
                 //Create a new cube for every position in the array
                 GameObject go = (GameObject)Instantiate(Resources.Load("cell"));
                 go.GetComponent<cell>().setWeight(UnityEngine.Random.Range(0, 99));

                 //Set up its rendering.
                 MeshRenderer mr = go.GetComponent<MeshRenderer>();
                 Material mat = new Material(Shader.Find("Diffuse"));

                 //set a random color
                 //subtracting 0.1 from the red value to make sure white never appears as a color that way I can accuratly count
                 //how many tiles have been stepped on by using the color white as a flag
                 mat.SetColor("_Color", new Color((float)r.NextDouble() - 0.1f, (float)r.NextDouble(), (float)r.NextDouble(), .5f));
                 mr.material = mat;

                 //Set the cubes position and scale
                 go.transform.position = new Vector3(i * CELL_SEPERATION, 0, j * CELL_SEPERATION);
                 go.transform.localScale = new Vector3(CELL_SCALE, CELL_SCALE, CELL_SCALE);

                 m_gameObjectArray[i, j] = go;
             }
         }

         //setup walls around perimeter
         for (int i = 0; i < mazeSizeY; i++)
         {
             m_gameObjectArray[0, i].GetComponent<cell>().setStatus(3);
             m_gameObjectArray[0, i].renderer.material.color = Color.green;
         }

         for (int i = 0; i < mazeSizeX; i++)
         {
             m_gameObjectArray[i, 0].GetComponent<cell>().setStatus(3);
             m_gameObjectArray[i, 0].renderer.material.color = Color.green;
         }

         for (int i = 0; i < mazeSizeX; i++)
         {
             m_gameObjectArray[i, mazeSizeY - 1].GetComponent<cell>().setStatus(3);
             m_gameObjectArray[i, mazeSizeY - 1].renderer.material.color = Color.green;
         }

         for (int i = 0; i < mazeSizeY; i++)
         {
             m_gameObjectArray[mazeSizeX - 1, i].GetComponent<cell>().setStatus(3);
             m_gameObjectArray[mazeSizeX - 1, i].renderer.material.color = Color.green;
         }


         //find the first cell to add to the maze which will be the exit
         //finds a random cell on the perimeter on a random side of the maze
         int side = UnityEngine.Random.Range(1, 4);
         IntVector2 activeCell = new IntVector2(0, 0);
         switch (side)
         {
             case 1: activeCell = new IntVector2(0, UnityEngine.Random.Range(1, mazeSizeY - 2)); break;
             case 2: activeCell = new IntVector2(mazeSizeX - 1, UnityEngine.Random.Range(1, mazeSizeY - 2)); break;
             case 3: activeCell = new IntVector2(UnityEngine.Random.Range(1, mazeSizeX - 2), 0); break;
             case 4: activeCell = new IntVector2(UnityEngine.Random.Range(1, mazeSizeX - 2), mazeSizeY - 1); break;
         }

         //set the exit cell color and mark it as the exit
         Vector3 positionTemp = m_gameObjectArray[activeCell.x, activeCell.y].transform.position;
         m_gameObjectArray[activeCell.x, activeCell.y].renderer.material.color = Color.white;

         //save this location as the exit for managing the door opening
         exitLocation = activeCell;

         //set the status of the exit cell to 4 which labels it as the exit
         m_gameObjectArray[activeCell.x, activeCell.y].GetComponent<cell>().setStatus(2);

         //step one cell away from the starting cell which will now be the exit
         switch (side)
         {
             case 1: activeCell.x++; break;
             case 2: activeCell.x--; break;
             case 3: activeCell.y++; break;
             case 4: activeCell.y--; break;
         }

         //tag for the goto statement below to go back through the loop if their are any frontier cells
     //remaining after the loop has exited
     start:

         bool frontierRemain = true;

         while (frontierRemain == true)
         {
             frontierRemain = false;

             if (checkFrontierForPaths(activeCell) == true)
             {
                 //set cell status to a wall and don't lower it
                 m_gameObjectArray[activeCell.x, activeCell.y].GetComponent<cell>().setStatus(3);
                 m_gameObjectArray[activeCell.x, activeCell.y].renderer.material.color = Color.green;


                 activeCell = findFrontierCells(activeCell);

                 if (activeCell.x == -1 && activeCell.y == -1)
                 {
                     activeCell = findCheapestAvailableFrontier();

                     if (activeCell.x > -1 && activeCell.y > -1)
                     {
                         frontierRemain = true;
                     }
                 }


             }
             else if (activeCell.x > -1 && activeCell.y > -1)
             {
                 Vector3 activeCellPositionTemp = m_gameObjectArray[activeCell.x, activeCell.y].transform.position;
                 m_gameObjectArray[activeCell.x, activeCell.y].transform.position = new Vector3(activeCellPositionTemp.x, activeCellPositionTemp.y - 5, activeCellPositionTemp.z);

                 //set the status of the starting cell to 2 which means it is a path in the maze
                 m_gameObjectArray[activeCell.x, activeCell.y].GetComponent<cell>().setStatus(2);

                 //call method to find the cells adjacent to the current cell
                 activeCell = findFrontierCells(activeCell);

                 if (activeCell.x == -1 && activeCell.y == -1)
                 {
                     activeCell = findCheapestAvailableFrontier();

                     if (activeCell.x > -1 && activeCell.y > -1)
                     {
                         frontierRemain = true;
                     }

                 }

                 frontierRemain = true;
             }
         }

         for (int i = 0; i < mazeSizeX; i++)
         {
             for (int j = 0; j < mazeSizeY; j++)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 1)
                 {
                     activeCell = new IntVector2(i, j);
                     goto start;
                 }
             }

         }
     }
    
    //When the current active cell runs out of frontier cells to check for, this method is called
    //to find the next cheapeast frontier cell available
     IntVector2 findCheapestAvailableFrontier()
     {
         int cheapestSoFar = 9999;
         IntVector2 cell = new IntVector2(-1, -1);

         //find the next cheapest fronier cell on the grid
         for (int i = 0; i < mazeSizeX; i++)
         {
             for (int j = 0; j < mazeSizeY; j++)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 1)
                 {
                     if (m_gameObjectArray[i, j].GetComponent<cell>().getWeight() < cheapestSoFar)
                     {
                         cell = new IntVector2(i, j);

                         cheapestSoFar = m_gameObjectArray[i, j].GetComponent<cell>().getWeight();
                     }
                 }
             }
         }

         return cell;
     }

    //Decides whether the current frontier path should be marked as a wall or path depending on the number
    //of paths currently connected to it. If the their are 2 or more paths connecting to this cell then it returns
    //true which is used to mark the cell as a wall. Also if it has 0 connected paths then it determins that this is an unreachable
    //area and returns true. if it returns false then that cell is used as a path
     bool checkFrontierForPaths(IntVector2 activeCell)
     {
         int paths = 0;

         if (activeCell.x > -1 && activeCell.y > -1)
         {
             if (m_gameObjectArray[activeCell.x - 1, activeCell.y].GetComponent<cell>().getStatus() == 2)
             { paths++; }

             if (m_gameObjectArray[activeCell.x + 1, activeCell.y].GetComponent<cell>().getStatus() == 2)
             { paths++; }

             if (m_gameObjectArray[activeCell.x, activeCell.y - 1].GetComponent<cell>().getStatus() == 2)
             { paths++; }

             if (m_gameObjectArray[activeCell.x, activeCell.y + 1].GetComponent<cell>().getStatus() == 2)
             { paths++; }

             if (paths >= 2 || paths == 0)
             { return true; }
         }

         return false;


     }

     //when a floor is lowered, this method is called to mark the neighboring cells as frontier cells and
     //return the cell with the lowest weight
     IntVector2 findFrontierCells(IntVector2 activeCell)
     {
         IntVector2 cheapestCell = new IntVector2(-1, -1);
         int currentCheapest = 9999;

         if (m_gameObjectArray[activeCell.x - 1, activeCell.y].GetComponent<cell>().getStatus() == 0)
         {
             m_gameObjectArray[activeCell.x - 1, activeCell.y].GetComponent<cell>().setStatus(1);

             if (m_gameObjectArray[activeCell.x - 1, activeCell.y].GetComponent<cell>().getWeight() < currentCheapest)
             {
                 currentCheapest = m_gameObjectArray[activeCell.x - 1, activeCell.y].GetComponent<cell>().getWeight();
                 cheapestCell = new IntVector2(activeCell.x - 1, activeCell.y);
             }
         }

         if (m_gameObjectArray[activeCell.x + 1, activeCell.y].GetComponent<cell>().getStatus() == 0)
         {
             m_gameObjectArray[activeCell.x + 1, activeCell.y].GetComponent<cell>().setStatus(1);

             if (m_gameObjectArray[activeCell.x + 1, activeCell.y].GetComponent<cell>().getWeight() < currentCheapest)
             {
                 currentCheapest = m_gameObjectArray[activeCell.x + 1, activeCell.y].GetComponent<cell>().getWeight();
                 cheapestCell = new IntVector2(activeCell.x + 1, activeCell.y);
             }
         }

         if (m_gameObjectArray[activeCell.x, activeCell.y - 1].GetComponent<cell>().getStatus() == 0)
         {
             m_gameObjectArray[activeCell.x, activeCell.y - 1].GetComponent<cell>().setStatus(1);

             if (m_gameObjectArray[activeCell.x, activeCell.y - 1].GetComponent<cell>().getWeight() < currentCheapest)
             {
                 currentCheapest = m_gameObjectArray[activeCell.x, activeCell.y - 1].GetComponent<cell>().getWeight();
                 cheapestCell = new IntVector2(activeCell.x, activeCell.y - 1);
             }
         }

         if (m_gameObjectArray[activeCell.x, activeCell.y + 1].GetComponent<cell>().getStatus() == 0)
         {
             m_gameObjectArray[activeCell.x, activeCell.y + 1].GetComponent<cell>().setStatus(1);

             if (m_gameObjectArray[activeCell.x, activeCell.y + 1].GetComponent<cell>().getWeight() < currentCheapest)
             {
                 currentCheapest = m_gameObjectArray[activeCell.x, activeCell.y + 1].GetComponent<cell>().getWeight();
                 cheapestCell = new IntVector2(activeCell.x, activeCell.y + 1);
             }
         }


         return cheapestCell;
     }

     //starts in the middle of the maze and searches for the first available cell that is a path then sets the players position
     //to above that cell
     void placePlayerStartPosition()
     {
         for (int i = mazeSizeX / 2; i < mazeSizeX; i++)
         {
             for (int j = mazeSizeY / 2; j < mazeSizeY; j++)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 2)
                 {
                     Vector3 tempCellPositon = m_gameObjectArray[i, j].transform.position;
                     m_firstPersonController.transform.position = new Vector3(m_gameObjectArray[i, j].transform.position.x, m_gameObjectArray[i, j].transform.position.y + 20, m_gameObjectArray[i, j].transform.position.z);

                     i = mazeSizeX; //break out of nested loop
                     j = mazeSizeY;
                 }
             }

         }
     }

     //places 4 keys in the first available path cell from each corner of the maze
     void placeKeys()
     {
         //place key 1
         for (int i = 0; i < mazeSizeX; i++)
         {
             for (int j = 0; j < mazeSizeY; j++)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 2)
                 {
                     if (exitLocation.x != i && exitLocation.y != j)    //check to make sure key isn't being placed on the exit door
                     {
                         GameObject key = (GameObject)Instantiate(Resources.Load("key"));
                         Vector3 tempCellPositon = m_gameObjectArray[i, j].transform.position;
                         key.transform.position = new Vector3(m_gameObjectArray[i, j].transform.position.x, m_gameObjectArray[i, j].transform.position.y + 4, m_gameObjectArray[i, j].transform.position.z);

                         i = mazeSizeX;     //break out of loops
                         j = mazeSizeY;
                     }
                 }
             }
         }

         //place key 2
         for (int i = mazeSizeX - 1; i > 0; i--)
         {
             for (int j = 0; j < mazeSizeY; j++)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 2)
                 {
                     if (exitLocation.x != i && exitLocation.y != j)
                     {
                         GameObject key = (GameObject)Instantiate(Resources.Load("key"));
                         Vector3 tempCellPositon = m_gameObjectArray[i, j].transform.position;
                         key.transform.position = new Vector3(m_gameObjectArray[i, j].transform.position.x, m_gameObjectArray[i, j].transform.position.y + 4, m_gameObjectArray[i, j].transform.position.z);

                         i = 0;            //break out of loops
                         j = mazeSizeY;
                     }
                 }
             }
         }

         //place key 3
         for (int i = 0; i < mazeSizeX; i++)
         {
             for (int j = mazeSizeY - 1; j > 0; j--)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 2)
                 {
                     if (exitLocation.x != i && exitLocation.y != j)
                     {
                         GameObject key = (GameObject)Instantiate(Resources.Load("key"));
                         Vector3 tempCellPositon = m_gameObjectArray[i, j].transform.position;
                         key.transform.position = new Vector3(m_gameObjectArray[i, j].transform.position.x, m_gameObjectArray[i, j].transform.position.y + 4, m_gameObjectArray[i, j].transform.position.z);

                         i = mazeSizeX;            //break out of loops
                         j = 0;
                     }
                 }
             }
         }

         //place key 4
         for (int i = mazeSizeX - 1; i > 0; i--)
         {
             for (int j = mazeSizeY - 1; j > 0; j--)
             {
                 if (m_gameObjectArray[i, j].GetComponent<cell>().getStatus() == 2)
                 {
                     if (exitLocation.x != i && exitLocation.y != j)
                     {
                         GameObject key = (GameObject)Instantiate(Resources.Load("key"));
                         Vector3 tempCellPositon = m_gameObjectArray[i, j].transform.position;
                         key.transform.position = new Vector3(m_gameObjectArray[i, j].transform.position.x, m_gameObjectArray[i, j].transform.position.y + 4, m_gameObjectArray[i, j].transform.position.z);

                         i = 0;            //break out of loops
                         j = 0;
                     }
                 }
             }
         }
     }

     //checks to see if player walks over a cell. If he does then change the color of the cell to white
     void checkToChangePanelColor()
     {
         if (Physics.Raycast(m_firstPersonController.transform.position, -m_firstPersonController.transform.up, out hitInfo))
         {
             if (hitInfo.transform.tag == "cell")
             {
                 if (hitInfo.transform.renderer.material.color != Color.white)
                 {
                     hitInfo.transform.GetComponent<cell>().changeColorWhite();
                     panelsSteppedOn++;
                     panelsSteppedOnGUI.GetComponent<panelsSteppedOn>().setText(panelsSteppedOn);
                 }
             }
         }
     }

     //checks to see if player walks into a key
     void checkForKeyPickUp()
    {
        if (Physics.Raycast(m_firstPersonController.transform.position, m_firstPersonController.transform.forward, out hitInfo, 2))
        {
            if (hitInfo.transform.tag == "key")
            {
                keysCollected++;
                hitInfo.transform.GetComponent<key>().destroyKey();
            }
        }
    }

    //check if all four keys are collected. if they are then open the door and change flag to indicate that the door has been opened
     void checkIfDoorShouldOpen()
    {
        if (isDoorOpened == false)
        {
            if (keysCollected >= 4)
            {
                Vector3 positionTemp = m_gameObjectArray[exitLocation.x, exitLocation.y].transform.position;
                m_gameObjectArray[exitLocation.x, exitLocation.y].transform.position = new Vector3(positionTemp.x, positionTemp.y - 5, positionTemp.z);
                isDoorOpened = true;
            }
        }
    }

     //checks to see if you are clicking a wall.
     //if you have stepped on 10 or more panels then you are able to click and lower
     // a wall at the cost of 10 of your traversed panels
     void checkMouseClick()
     {
         mouse = Input.GetKey(KeyCode.Mouse0);

         ray = Camera.main.ScreenPointToRay(Input.mousePosition);

         if (mouse == true && oldMouse == false)
         {
             if (Physics.Raycast(ray, out hitInfo))
             {
                 if (hitInfo.collider.tag == "cell" && panelsSteppedOn >= costToLowerWall)
                 {
                     //checking to see if the cube you clicked is a wall
                     if (hitInfo.transform.GetComponent<cell>().getStatus() == 3)
                     {
                         Vector3 tempPosition = hitInfo.collider.transform.position;     //physically lower the wall piece
                         hitInfo.collider.transform.position = new Vector3(tempPosition.x, tempPosition.y - 5, tempPosition.z);

                         hitInfo.transform.GetComponent<cell>().setStatus(2);    //set the status of the lowered wall to a pathway
                         panelsSteppedOn -= costToLowerWall;  //subtract the cost of lowering a wall from your traversed panel count
                     }

                 }
             }
         }


         oldMouse = mouse;
     }


}
